# 09-队列：队列在线程池等有限资源池中的应用

## 内容摘抄

CPU 资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致 CPU 频繁切换，处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。

**当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？**

实际上，这些问题并不复杂，其底层的数据结构就是我们今天要学的内容，**队列（queue）**。

### 如何理解队列？

- **先进者先出，这就是典型的“队列”**
- 栈只支持两个基本操作：**入栈 push()和出栈 pop()**。
- 队列跟栈非常相似，支持的操作也很有限，也是一种**操作受限的线性表数据结构**，最基本的操作也是两个：
    - 入队 enqueue()，放一个数据到队列尾部；
    - 出队 dequeue()，从队列头部取一个元素。

![](_v_images/20200529200726919_31488.png =571x)

作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如**循环队列、阻塞队列、并发队列**。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。

### 顺序队列和链式队列

数组实现的队列叫作**顺序队列**，用链表实现的队列叫作**链式队列**。

队列需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾。

如图，当 a、b、c、d 依次入队之后，队列中的 head 指针指向下标为 0 的位置，tail 指针指向下标为 4 的位置。

![](_v_images/20200529201200689_12305.png =571x)

当我们调用两次出队操作之后，队列中 head 指针指向下标为 2 的位置，tail 指针仍然指向下标为 4 的位置。

![](_v_images/20200529201259234_26130.png =571x)

随着不停地进行入队、出队操作，head 和 tail 都会持续往后移动。当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。这个问题该如何解决呢？

如果没有空闲空间了，我们只需要在入队时，再集中触发一次数据的搬移操作.

当队列的 tail 指针移动到数组的最右边后，如果有新的数据入队，我们可以将 head 到 tail 之间的数据，整体搬移到数组中 0 到 tail-head 的位置。如图

![](_v_images/20200529202603929_1249.png =571x)

**基于链表的队列实现方法**

基于链表的实现，我们同样需要两个指针：head 指针和 tail 指针。它们分别指向链表的第一个结点和最后一个结点。如图所示，入队时，tail->next= new_node, tail = tail->next；出队时，head = head->next。

![](_v_images/20200529202747933_25779.png =571x)

### 循环队列

![](_v_images/20200529203004260_21611.png =571x)

图中这个队列的大小为 8，当前 head=4，tail=7。当有一个新的元素 a 入队时，我们放入下标为 7 的位置。但这个时候，我们并不把 tail 更新为 8，而是将其在环中后移一位，到下标为 0 的位置。当再有一个元素 b 入队时，我们将 b 放入下标为 0 的位置，然后 tail 加 1 更新为 1。所以，在 a，b 依次入队之后，循环队列中的元素就变成了下面的样子：

![](_v_images/20200529203116444_29951.png =571x)

要想写出没有 bug 的循环队列的实现代码，我个人觉得，最关键的是**，确定好队空和队满的判定条件**。

队满时，**(tail+1)%n=head**.队列满时，图中的 tail 指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。

### 阻塞队列和并发队列

**阻塞队列其实就是在队列基础上增加了阻塞操作**。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。

![](_v_images/20200529203501500_24777.png =571x)

你应该已经发现了，上述的定义就是一个“生产者 - 消费者模型”！是的，我们可以使用阻塞队列，轻松实现一个“**生产者 - 消费者模型**”！

这种基于阻塞队列实现的“生产者 - 消费者模型”，**可以有效地协调生产和消费的速度**。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。而且不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，**来提高数据的处理效率**。比如前面的例子，我们可以多配置几个“消费者”，来应对一个“生产者”。如图

![](_v_images/20200529203656513_26401.png =571x)

**线程安全的队列我们叫作并发队列**。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是**锁粒度大并发度会比较低**，**同一时刻仅允许一个存或者取操作**。实际上，基于数组的循环队列，利用**CAS 原子操作**，可以实现非常高效的并发队列。这也是 **循环队列比链式队列应用更加广泛的原因**。在实战篇讲 Disruptor 的时候，我会再详细讲并发队列的应用。

## 解答开篇

线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？

我们一般有两种处理策略。

- 第一种是非阻塞的处理方式，直接拒绝任务请求；
- 另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。

那如何存储排队的请求呢？**我们希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求**。

队列有基于链表和基于数组这两种实现方式。这两种实现方式对于排队请求又有什么区别呢？

- 基于链表的实现方式，可以实现一个**支持无限排队的无界队列**（unbounded queue），但是**可能会导致过多的请求排队等待，请求处理的响应时间过长**。所以，针对**响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的**。
- 而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。**队列太大导致等待的请求太多**，**队列太小会导致无法充分利用系统资源、发挥最大性能**。除了前面讲到队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，**对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队**。

## 课后思考

1. 除了线程池这种池结构会用到队列排队请求，你还知道有哪些类似的池结构或者场景中会用到队列的排队请求呢？
2. 今天讲到并发队列，关于如何实现无锁并发队列，网上有非常多的讨论。对这个问题，你怎么看呢？

## 评论

循环队列的长度设定需要对并发数据有一定的预测，否则会丢失太多请求

----

1.分布式应用中的消息队列，也是一种队列结构
2.考虑使用CAS实现无锁队列，则在入队前，获取tail位置，入队时比较tail是否发生变化，如果否，则允许入队，反之，本次入队失败。出队则是获取head位置，进行cas。
个人浅见，请批评指正

----

老师，循环队列的数组实现，在您的代码中，入队时会空留出一个位置，而且我感觉不太好理解。我定义一个记录队列大小的值size，当这个值与数组大小相等时，表示队列已满，当tail达到最底时，size不等于数组大小时，tail就指向数组第一个位置。当出队时，size—，入队时size++
